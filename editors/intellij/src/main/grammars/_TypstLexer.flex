package org.tinymist.intellij.language.lexer;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.tree.IElementType;
import static org.tinymist.intellij.language.psi.TypstTypes.*; // Assuming TypstTypes is generated by Grammar-Kit

%%{
  %class _TypstLexer
  %implements FlexLexer
  %unicode
  %function advance
  %type IElementType
  %eofval{ 
    return null;
  %eofval}

  // Line and Column tracking for better error reporting (optional but good practice)
  %scanerror Throws: java.io.IOException
  %line
  %column

  // Macros (shortcuts for common patterns)
  WhiteSpace = [ \t\r\n]+
  LineTerminator = \r|\n|\r\n
  // Comments
  LineComment = "//" [^\r\n]* {LineTerminator}? | "//" [^\r\n]*
  BlockComment = "/*" ( [^*] | "*"+ [^*/] )* "*"* "*/"

  // Keywords (example set)
  LetKeyword = "#let"
  SetKeyword = "#set"
  ShowKeyword = "#show"
  IfKeyword = "#if"
  ElseKeyword = "#else"
  ForKeyword = "#for"
  InKeyword = "#in"
  WhileKeyword = "#while"
  BreakKeyword = "#break"
  ContinueKeyword = "#continue"
  ReturnKeyword = "#return"
  ImportKeyword = "#import"
  IncludeKeyword = "#include"

  // Literals
  BooleanLiteral = "true" | "false"
  // Number literals (simplified: integers and basic floats)
  NumberLiteral = [0-9]+ ( "." [0-9]+ )? ( ("e"|"E") ("+"|"-")? [0-9]+ )?
  // String literal (simplified, does not handle escape sequences fully)
  StringLiteral = \" ( [^\"\\] | (\\[^\r\n]) )* \"

  // Identifiers
  Identifier = [:jletter:] [:jletterdigit:]*
  // Typst specific content elements
  Hash = "#"
  Star = "*"
  Underscore = "_"
  Backtick = "`"
  Equals = "="
  Colon = ":"
  Comma = ","
  Dot = "."
  LParen = "("
  RParen = ")"
  LBrace = "{"
  RBrace = "}"
  LBracket = "["
  RBracket = "]"
  Plus = "+"
  Minus = "-"
  Slash = "/"
  Percent = "%"
  Lt = "<"
  Gt = ">"
  Le = "<="
  Ge = ">="
  Eq = "=="
  Neq = "!="
  And = "and"
  Or = "or"
  Not = "not"

  // Any other character that isn't part of a defined token (e.g., plain text in markup)
  // This is a very broad rule and needs careful handling in the grammar.
  // For a rich text language like Typst, a pure JFlex approach to "TEXT" can be tricky.
  // Often, the parser needs to be more context-aware.
  // Consider if TEXT should be more restricted or handled differently by the parser.
  TextCharacter = [^ \t\r\n\/\*\_\`#=\[\](){}:,.+\-<>!"0-9]

%}

// Lexical Rules
// The order matters: JFlex tries to match the longest possible sequence, 
// and among those of equal length, the one listed first.

<YYINITIAL> {
  {WhiteSpace}                 { return com.intellij.psi.TokenType.WHITE_SPACE; }

  {LineComment}                { return LINE_COMMENT; }
  {BlockComment}               { return BLOCK_COMMENT; }

  // Keywords
  {LetKeyword}                 { return KW_LET; }
  {SetKeyword}                 { return KW_SET; }
  {ShowKeyword}                { return KW_SHOW; }
  {IfKeyword}                  { return KW_IF; }
  {ElseKeyword}                { return KW_ELSE; }
  {ForKeyword}                 { return KW_FOR; }
  {InKeyword}                  { return KW_IN; }
  {WhileKeyword}               { return KW_WHILE; }
  {BreakKeyword}               { return KW_BREAK; }
  {ContinueKeyword}            { return KW_CONTINUE; }
  {ReturnKeyword}              { return KW_RETURN; }
  {ImportKeyword}              { return KW_IMPORT; }
  {IncludeKeyword}             { return KW_INCLUDE; }
  
  // Literals
  {BooleanLiteral}             { return BOOLEAN_LITERAL; }
  {NumberLiteral}              { return NUMBER_LITERAL; }
  {StringLiteral}              { return STRING_LITERAL; }

  // Identifiers
  {Identifier}                 { return IDENTIFIER; }

  // Symbols & Operators
  {Hash}                       { return HASH; }
  {Star}                       { return OP_STAR; } // Might be for emphasis or multiplication
  {Underscore}                 { return OP_UNDERSCORE; } // Might be for emphasis or part of id
  {Backtick}                   { return BACKTICK; } // For raw text or code blocks
  {Equals}                     { return OP_EQ_SIGN; } // Assignment or equality in #set, #if
  {Colon}                      { return COLON; }
  {Comma}                      { return COMMA; }
  {Dot}                        { return DOT; }
  {LParen}                     { return LPAREN; }
  {RParen}                     { return RPAREN; }
  {LBrace}                     { return LBRACE; }
  {RBrace}                     { return RBRACE; }
  {LBracket}                   { return LBRACKET; }
  {RBracket}                   { return RBRACKET; }
  {Plus}                       { return OP_PLUS; }
  {Minus}                      { return OP_MINUS; }
  {Slash}                      { return OP_SLASH; } // Division or path component
  {Percent}                    { return OP_PERCENT; }
  {Lt}                         { return OP_LT; }
  {Gt}                         { return OP_GT; }
  {Le}                         { return OP_LE; }
  {Ge}                         { return OP_GE; }
  {Eq}                         { return OP_EQ; } // Equality check
  {Neq}                        { return OP_NEQ; }
  {And}                        { return KW_AND; }
  {Or}                         { return KW_OR; }
  {Not}                        { return KW_NOT; }
  
  // Text character - this should be fairly low precedence
  // Consider making this more specific if possible, or rely on parser context
  {TextCharacter}+             { return TEXT_CONTENT; }
}

// Fallback for any other character - this will mark it as a BAD_CHARACTER token
[^] { return com.intellij.psi.TokenType.BAD_CHARACTER; } 