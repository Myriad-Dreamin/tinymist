use core::fmt;
use std::hash::{Hash, Hasher};
use std::io::{Read, Seek, SeekFrom, Write};
use std::path::PathBuf;
use std::{cmp::Ordering, path::Path, str::FromStr};

use clap::ValueHint;
use ecow::{eco_vec, EcoVec};
use serde::{Deserialize, Serialize};
use tinymist_std::error::prelude::*;
use tinymist_std::path::unix_slash;
use tinymist_std::{bail, ImmutPath};
use tinymist_world::EntryReader;
use typst::diag::EcoString;
use typst::syntax::FileId;

pub mod task;
pub use task::*;

use crate::LspWorld;

use super::{Pages, PdfStandard, TaskWhen};

pub const LOCK_FILENAME: &str = "tinymist.lock";

const LOCK_VERSION: &str = "0.1.0-beta0";

pub const PROJECT_ROUTE_USER_ACTION_PRIORITY: u32 = 256;

#[derive(Debug, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "kebab-case", tag = "version")]
pub enum LockFileCompat {
    #[serde(rename = "0.1.0-beta0")]
    Version010Beta0(LockFile),
    #[serde(untagged)]
    Other(serde_json::Value),
}

impl LockFileCompat {
    pub fn version(&self) -> Result<&str> {
        match self {
            LockFileCompat::Version010Beta0(..) => Ok(LOCK_VERSION),
            LockFileCompat::Other(v) => v
                .get("version")
                .and_then(|v| v.as_str())
                .context("missing version field"),
        }
    }

    pub fn migrate(self) -> Result<LockFile> {
        match self {
            LockFileCompat::Version010Beta0(v) => Ok(v),
            this @ LockFileCompat::Other(..) => {
                bail!(
                    "cannot migrate from version: {}",
                    this.version().unwrap_or("unknown version")
                )
            }
        }
    }
}

#[derive(Debug, Default, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub struct LockFile {
    // The lock file version.
    // version: String,
    /// The project's document (input).
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub document: Vec<ProjectInput>,
    /// The project's task (output).
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub task: Vec<ProjectTask>,
    /// The project's task route.
    #[serde(skip_serializing_if = "EcoVec::is_empty", default)]
    pub route: EcoVec<ProjectRoute>,
}

impl LockFile {
    pub fn get_document(&self, id: &Id) -> Option<&ProjectInput> {
        self.document.iter().find(|i| &i.id == id)
    }

    pub fn replace_document(&mut self, input: ProjectInput) {
        let id = input.id.clone();
        let index = self.document.iter().position(|i| i.id == id);
        if let Some(index) = index {
            self.document[index] = input;
        } else {
            self.document.push(input);
        }
    }

    pub fn replace_task(&mut self, task: ProjectTask) {
        let id = task.id().clone();
        let index = self.task.iter().position(|i| *i.id() == id);
        if let Some(index) = index {
            self.task[index] = task;
        } else {
            self.task.push(task);
        }
    }

    pub fn replace_route(&mut self, route: ProjectRoute) {
        let id = route.id.clone();

        self.route.retain(|i| i.id != id);
        self.route.push(route);
    }

    pub fn sort(&mut self) {
        self.document.sort_by(|a, b| a.id.cmp(&b.id));
        self.task
            .sort_by(|a, b| a.doc_id().cmp(b.doc_id()).then_with(|| a.id().cmp(b.id())));
        // the route's order is important, so we don't sort them.
    }

    pub fn serialize_resolve(&self) -> String {
        let content = toml::Table::try_from(self).unwrap();

        let mut out = String::new();

        // At the start of the file we notify the reader that the file is generated.
        // Specifically Phabricator ignores files containing "@generated", so we use
        // that.
        let marker_line = "# This file is automatically @generated by tinymist.";
        let extra_line = "# It is not intended for manual editing.";

        out.push_str(marker_line);
        out.push('\n');
        out.push_str(extra_line);
        out.push('\n');

        out.push_str(&format!("version = {LOCK_VERSION:?}\n"));

        let document = content.get("document");
        if let Some(document) = document {
            for document in document.as_array().unwrap() {
                out.push('\n');
                out.push_str("[[document]]\n");
                emit_document(document, &mut out);
            }
        }

        let route = content.get("route");
        if let Some(route) = route {
            for route in route.as_array().unwrap() {
                out.push('\n');
                out.push_str("[[route]]\n");
                emit_route(route, &mut out);
            }
        }

        let task = content.get("task");
        if let Some(task) = task {
            for task in task.as_array().unwrap() {
                out.push('\n');
                out.push_str("[[task]]\n");
                emit_output(task, &mut out);
            }
        }

        return out;

        fn emit_document(input: &toml::Value, out: &mut String) {
            let table = input.as_table().unwrap();
            out.push_str(&table.to_string());
        }

        fn emit_output(output: &toml::Value, out: &mut String) {
            let mut table = output.clone();
            let table = table.as_table_mut().unwrap();
            // replace transform with task.transforms
            if let Some(transform) = table.remove("transform") {
                let mut task_table = toml::Table::new();
                task_table.insert("transform".to_string(), transform);

                table.insert("task".to_string(), task_table.into());
            }

            out.push_str(&table.to_string());
        }

        fn emit_route(route: &toml::Value, out: &mut String) {
            let table = route.as_table().unwrap();
            out.push_str(&table.to_string());
        }
    }

    pub fn update(cwd: &Path, f: impl FnOnce(&mut Self) -> Result<()>) -> Result<()> {
        let fs = tinymist_std::fs::flock::Filesystem::new(cwd.to_owned());

        let mut lock_file = fs
            .open_rw_exclusive_create(LOCK_FILENAME, "project commands")
            .context("tinymist.lock")?;

        let mut data = vec![];
        lock_file.read_to_end(&mut data).context("read lock")?;

        let old_data =
            std::str::from_utf8(&data).context("tinymist.lock file is not valid utf-8")?;

        let mut state = if old_data.trim().is_empty() {
            LockFile {
                document: vec![],
                task: vec![],
                route: eco_vec![],
            }
        } else {
            let old_state = toml::from_str::<LockFileCompat>(old_data)
                .context_ut("tinymist.lock file is not a valid TOML file")?;

            let version = old_state.version()?;
            match Version(version).partial_cmp(&Version(LOCK_VERSION)) {
                Some(Ordering::Equal | Ordering::Less) => {}
                Some(Ordering::Greater) => {
                    bail!(
                    "trying to update lock file having a future version, current tinymist-cli supports {LOCK_VERSION}, the lock file is {version}",
                );
                }
                None => {
                    bail!(
                    "cannot compare version, are version strings in right format? current tinymist-cli supports {LOCK_VERSION}, the lock file is {version}",
                );
                }
            }

            old_state.migrate()?
        };

        f(&mut state)?;

        // todo: for read only operations, we don't have to compare it.
        state.sort();
        let new_data = state.serialize_resolve();

        // If the lock file contents haven't changed so don't rewrite it. This is
        // helpful on read-only filesystems.
        if old_data == new_data {
            return Ok(());
        }

        // todo: even if cargo, they don't update the lock file atomically. This
        // indicates that we may get data corruption if the process is killed
        // while writing the lock file. This is sensible because `Cargo.lock` is
        // only a "resolved result" of the `Cargo.toml`. Thus, we should inform
        // users that don't only persist configuration in the lock file.
        lock_file.file().set_len(0).context(LOCK_FILENAME)?;
        lock_file.seek(SeekFrom::Start(0)).context(LOCK_FILENAME)?;
        lock_file
            .write_all(new_data.as_bytes())
            .context(LOCK_FILENAME)?;

        Ok(())
    }

    pub fn read(dir: &Path) -> Result<Self> {
        let fs = tinymist_std::fs::flock::Filesystem::new(dir.to_owned());

        let mut lock_file = fs
            .open_ro_shared(LOCK_FILENAME, "project commands")
            .context(LOCK_FILENAME)?;

        let mut data = vec![];
        lock_file.read_to_end(&mut data).context(LOCK_FILENAME)?;

        let data = std::str::from_utf8(&data).context("tinymist.lock file is not valid utf-8")?;

        let state = toml::from_str::<LockFileCompat>(data)
            .context_ut("tinymist.lock file is not a valid TOML file")?;

        state.migrate()
    }
}

/// A scalar that is not NaN.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Scalar(f32);

impl TryFrom<f32> for Scalar {
    type Error = &'static str;

    fn try_from(value: f32) -> Result<Self, Self::Error> {
        if value.is_nan() {
            Err("NaN is not a valid scalar value")
        } else {
            Ok(Scalar(value))
        }
    }
}

impl PartialEq for Scalar {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Eq for Scalar {}

impl Hash for Scalar {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0.to_bits().hash(state);
    }
}

impl PartialOrd for Scalar {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Scalar {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.0.partial_cmp(&other.0).unwrap()
    }
}

/// A project ID.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct Id(String);

impl Id {
    pub fn new(s: String) -> Self {
        Id(s)
    }

    pub fn from_world(world: &LspWorld) -> Option<Self> {
        let entry = world.entry_state();
        let id = unix_slash(entry.main()?.vpath().as_rootless_path());

        let path = &ResourcePath::from_user_sys(Path::new(&id));
        Some(path.into())
    }
}

impl fmt::Display for Id {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

/// The id of a document.
///
/// If an identifier is not provided, the document's path is used as the id.
#[derive(Debug, Clone, clap::Parser)]
pub struct DocIdArgs {
    /// Give a name to the document.
    #[clap(long = "name")]
    pub name: Option<String>,
    /// Path to input Typst file.
    #[clap(value_hint = ValueHint::FilePath)]
    pub input: String,
}

impl From<&ResourcePath> for Id {
    fn from(value: &ResourcePath) -> Self {
        Id(value.to_string())
    }
}

impl From<&DocIdArgs> for Id {
    fn from(args: &DocIdArgs) -> Self {
        if let Some(id) = &args.name {
            Id(id.clone())
        } else {
            (&ResourcePath::from_user_sys(Path::new(&args.input))).into()
        }
    }
}

/// A resource path.
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct ResourcePath(EcoString, String);

impl fmt::Display for ResourcePath {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.0, self.1)
    }
}

impl FromStr for ResourcePath {
    type Err = &'static str;

    fn from_str(value: &str) -> Result<Self, Self::Err> {
        let mut parts = value.split(':');
        let scheme = parts.next().ok_or("missing scheme")?;
        let path = parts.next().ok_or("missing path")?;
        if parts.next().is_some() {
            Err("too many colons")
        } else {
            Ok(ResourcePath(scheme.into(), path.to_string()))
        }
    }
}

impl serde::Serialize for ResourcePath {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> serde::Deserialize<'de> for ResourcePath {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = String::deserialize(deserializer)?;
        value.parse().map_err(serde::de::Error::custom)
    }
}

impl ResourcePath {
    pub fn from_user_sys(inp: &Path) -> Self {
        let rel = if inp.is_relative() {
            inp.to_path_buf()
        } else {
            let cwd = std::env::current_dir().unwrap();
            pathdiff::diff_paths(inp, &cwd).unwrap()
        };
        let rel = unix_slash(&rel);
        ResourcePath("file".into(), rel.to_string())
    }

    pub fn from_file_id(id: FileId) -> Self {
        let package = id.package();
        match package {
            Some(package) => ResourcePath(
                "file_id".into(),
                format!("{package}{}", unix_slash(id.vpath().as_rooted_path())),
            ),
            None => ResourcePath(
                "file_id".into(),
                format!("$root{}", unix_slash(id.vpath().as_rooted_path())),
            ),
        }
    }

    pub fn to_abs_path(&self, rel: &Path) -> Option<PathBuf> {
        if self.0 == "file" {
            let path = Path::new(&self.1);
            if path.is_absolute() {
                Some(path.to_owned())
            } else {
                Some(rel.join(path))
            }
        } else {
            None
        }
    }
}

/// A project input specifier.
#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct ProjectInput {
    /// The project's ID.
    pub id: Id,
    /// The project's root directory.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub root: Option<ResourcePath>,
    /// The project's main file.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub main: Option<ResourcePath>,
    /// The project's font paths.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub font_paths: Vec<ResourcePath>,
    /// Whether to use system fonts.
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub system_fonts: bool,
    /// The project's package path.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub package_path: Option<ResourcePath>,
    /// The project's package cache path.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub package_cache_path: Option<ResourcePath>,
}

/// A project route specifier.
#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct ProjectMaterial {
    /// The root of the project that the material belongs to.
    pub root: EcoString,
    /// A project.
    pub id: Id,
    /// The files.
    pub files: Vec<ResourcePath>,
}

/// A project route specifier.
#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct ProjectPathMaterial {
    /// The root of the project that the material belongs to.
    pub root: EcoString,
    /// A project.
    pub id: Id,
    /// The files.
    pub files: Vec<PathBuf>,
}

impl ProjectPathMaterial {
    pub fn from_deps(doc_id: Id, files: EcoVec<ImmutPath>) -> Self {
        let mut files: Vec<_> = files.into_iter().map(|p| p.as_ref().to_owned()).collect();
        files.sort();

        ProjectPathMaterial {
            root: EcoString::default(),
            id: doc_id,
            files,
        }
    }
}

/// A project route specifier.
#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct ProjectRoute {
    /// A project.
    pub id: Id,
    /// The priority of the project. (lower numbers are higher priority).
    pub priority: u32,
}

struct Version<'a>(&'a str);

impl PartialEq for Version<'_> {
    fn eq(&self, other: &Self) -> bool {
        semver::Version::parse(self.0)
            .ok()
            .and_then(|a| semver::Version::parse(other.0).ok().map(|b| a == b))
            .unwrap_or(false)
    }
}

impl PartialOrd for Version<'_> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        let lhs = semver::Version::parse(self.0).ok()?;
        let rhs = semver::Version::parse(other.0).ok()?;
        Some(lhs.cmp(&rhs))
    }
}
